每个js对象都是一个属性集合，相互之间没有任何联系。在js中，也可以定义对象的类，让每个对象都共享某些属性。

对象常见的用法是创建、设置、查找、删除、检测、枚举它的属性。

除了包含属性外，每个对象还拥有三个相关的对象特性：对象的原型、对象的类、对象的扩展标记。


类的现是基于其原型继承机制的，如果两个实力对象都从同一个原型对象上继承了属性，可以认为它们是同一个类的实力。

如果定义一个原型对象，然后通过函数创建一个继承自它的对象，这样就定义了一个js类。

对象直接量定义的对象 —>原型对象（Object.prototype）
new+构造函数创建的对象 —>原型对象（构造函数.prototype）
Object.create()  创建的对象 —>原型对象（第一个参数）

属性赋值操作首先检查原型链，以此判定是否允许赋值操作。如果允许，它也总是在原始对象上创建属性或对已有的属性赋值，而不会去修改原型链。在js中，只有在查询属性时才会体会到继承的存在，而设置属性则和继承无关。

js中基于原型的继承机制是动态的：对象从其原型继承属性，如果创建对象之后原型的属性发生改变，也会影响到继承这个原型的所有实力对象。着意味着我们可以通过给远行对象添加新方法来扩充类。

查询一个不存在的属性并不会报错，而是返回undefined。但是，如果对象不存在，那么试图查询这个不存在对象的属性就会报错。

delete只是断开属性和宿主对象的联系，而不会去操作属性中的值。delete不能操作继承的属性。

检测属性，除了in运算符之外，也可以使用”!===”判断一个属性是否是undefined。
对象的hasOwnProperty()方法用来检测给定的名字是否是对象的自有属性，对于继承属性它将返回false。
propertyIsEnumerable()是hasOwnProperty()的增强版，只有检测到是自有属性且这个属性的可枚举性为true时他才返回true。

Object.keys() 返回一个数组，这个数组由对象中可枚举的自由属性的名字组成。
Object.getOwnPropertyNames() 返回对象的所有自由属性的名称，不仅仅是可枚举的属性。

通过调用Object.getOwnPropertyDescriptor()可以获得某个对象特定属性的描述特性对象。其中writable、enumerable、configurable都是布尔值，value是属性的取值。

要想设置属性特性，需要调用Object.defineProperty()。如果同时修改或创建多个属性，可以用Object.defineProperties()。

将对象作为参数传入Object.getPrototypeOf()可以查询它的原型；老版本中使用表达式 “对象.constructor.prototype”来检测一个对象的原型。通过new表达式创建的对象，通常继承一个constructor属性，这个属性指代创建这个对象的构造函数。

要检测一个对象是否是另一个对象的原型（或处于原型链中），可以使用isPrototypeOf()方法。例如 p.isPrototypeOf(o)：检测p是否是o的原型。  

通过将对象传入 Object.isExtensible() 来判断该对象是否是可扩展的。如果想将对象转换为不可扩展的，需要调用Object.preventExtensions()，将待转换的对象作为参数传进去。  

