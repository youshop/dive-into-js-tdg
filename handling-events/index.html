<!DOCTYPE html>
<html>
  <head>
    <title>事件处理</title>
    <meta charset="utf-8" />
    <script type="text/javascript" src="http://havard.github.io/node.js-intro-norwegian/presentation/remark-0.3.4.min.js"></script>
    <style type="text/css" media="screen">
      @import url(http://fonts.googleapis.com/css?family=Ubuntu+Condensed);
      body {
        font-family: 'Ubuntu Condensed', sans-serif; 
        font-size: 20px;
        line-height: 1.6;
      }
      pre code {
        -webkit-border-radius: 6px;
        -moz-border-radius: 6px;
        border-radius: 6px;
        background-color: #333; color: #fff; padding: 1em 2em;
      }
      pre code .number, pre code.css .value, pre code.css .value .number { color: #0086F7; font-weight: bold; }
      pre code .keyword, pre code .keymethods, pre code .tag .title { color: #FB660A; font-weight: bold; }
      pre code.css .id, pre code .symbol { color: #FB660A; font-weight: normal; }
      pre code .string, pre code .tag .value { color: #0091E2; }
      pre code .function, pre code.css .class, pre code .preprocessor { color: #87A558; }
      pre code .title { color: #DBEC62; font-weight: normal; }
      pre code .params { color: #87A558; }
      pre code .literal { }
      ul { }
      li { margin-bottom: 1em; }

      p > code, li > code { padding: 1px 4px; border: 1px solid #CCC; background-color: #EEE; }

      #slideshow .slide .content { padding: 1em 3em; 
        background: url(presentation/icon.png) no-repeat top right; }

      #slideshow .slide > .splash { padding: 1em 3em; 
        background: url(presentation/nodejs-splash.png) no-repeat center;
        color: #EEE; text-align: right; vertical-align: bottom; }

        #slideshow .slide > .left
        {
          text-align: left;
        }

      #slideshow .slide .content code { font-family: 'Consolas', monospace; font-size: 17px; }
      code { position: relative; text-align: left; }
      code .function {color: #900;}
      iframe { border: 0; width: 100%; }
    </style>
  </head>
  <body>
    <textarea id="source">
<big>Håvard Stranden</big><br/>

---
.center.middle
# 事件处理 

---
JavaScript使用单线程编程方式，采用了异步事件驱动编程模型。浏览器产生事件（event），JavaScript关注特定类型的事件，注册当这类事件发生时要调用多一个或多个函数（event handler）。等待事件发生，然后响应他们。

### 涉及到的一些概念，
* 事件类型（event type），如“mousemove”，“keydown”
* 事件目标（event target）是发生事件与之相关的对象，如果Window, Document, Element
* 事件处理程序（event handler）或者事件监听程序（event listener）是处理响应事件的函数
* 事件对象（event object）是与特定事件相关且包含有关该事件详细信息的对象。包含事件类型（type）和指定事件目标的target属性等
* 事件传播（event propagation）是浏览器决定哪个对象触发起事件处理程序的过程。有向上传播或“冒泡”和事件捕获（event capturing）

---

## 传统事件类型
### 表单事件
`<form`>元素会触发submit和reset事件，input，select，textarea等会出发change事件，通过键盘改变焦点会出发 focus和blur事件。通过事件处理程序可以取消submit和reset事件的默认操作（return false或者event.preventDefault()）。
 
### Window事件
DOMContentLoaded和readystatechange是load事件的替代方案，当文档和其元素为操作准备就绪，**但外部资源完全加载完毕之前**，浏览器会触发他们。`<img`>元素也能为load和error事件注册处理程序，如完全加载或者加载错误就会触发它们。当用户调整浏览器窗口大小或滚动它时会触发resize和scroll事件。scroll也能在**任何可以滚动**的文档元素上触发（设置CSS的overflow属性）
[DOMContentLoaded vs load区别](./code/domloaded.html)

---
### jQuery 1.11.3中DOMContentLoaded和onreadystatechange的使用

    .javascript
    if ( document.readyState === "complete" ) {
        // Handle it asynchronously to allow scripts the opportunity to delay ready
        setTimeout( jQuery.ready );

        // Standards-based browsers support DOMContentLoaded
    } else if ( document.addEventListener ) {
        // Use the handy event callback
        document.addEventListener( "DOMContentLoaded", completed, false );
   
        // A fallback to window.onload, that will always work
        window.addEventListener( "load", completed, false );
        // If IE event model is used
    } else {
        // Ensure firing before onload, maybe late but safe also for iframes
        document.attachEvent( "onreadystatechange", completed );
   
        // A fallback to window.onload, that will always work
        window.attachEvent( "onload", completed );

---
## 注册事件处理程序

IE9之前IE不支持addEventListener()，IE5之后才有了类似的方法attachEvent()和detachEvent()。
* IE事件模型不支持事件捕获，所以attachEvent只要求事件类型和处理程序函数
* 要给attachEvent()传递"on"前缀，如"onclick"

### 设置JavaScript对象属性为事件处理程序
按照约定，事件处理程序属性的名字由"on"后面跟着事件名组成：onclick、onchange、onload、onmouseover等。**区分大小写**，所有都是小写，即使事件类型是由多个词组成（比如“readystatechange”）

    .javascript
    window.onload = function() {
        var elt = document.getElementById("shipping_address");

        elt.onsubmit = function() { 
            return validate(this); 
        }
    }

---
### 设置HTML标签属性为事件处理程序
设置HTML标签属性为事件处理函数的主体，也可以注册事件处理程序

    .javascript
    <button onclick="alert('Thank you');">Click here</button>
在JavaScript中处理程序在Window对象上注册。在HTML中把他们放到`<body`>标签上。

onfocus    | ononline   | onresize       | onhashchange
onpagehide | onstorage  | onbeforeunload | onafterprint
onpageshow | onblur     | onmessage      | onpopstate
onunload   | onerror    | onoffline      | onredo

### addEventListener()
在除IE8及之前版本外的所有浏览器都支持的事件都支持使用addEventListener()方法。它接受三个参数，第一个是要注册处理程序的事件类型的字符串，第二个是事件发生时要调用的函数。最后一个参数是布尔值，通常情况下传递false。如果相反传递了true，那么函数将注册为捕获事件处理程序。[事件冒泡和捕获的区别](./code/buble-capture.html)

---
### attachEvent()
IE9之前IE不支持addEventListener()，IE5之后才有了类似的方法attachEvent()和detachEvent()。
* IE事件模型不支持事件捕获，所以attachEvent只要求事件类型和处理程序函数
* 要给attachEvent()传递"on"前缀，如"onclick"

---
### 事件处理的返回值
事件处理程序返回值为false的时候会阻止事件的默认操作。例如，表单提交按钮的onclick事件程序返回false阻止浏览器提交表单。输入域的onkeypress事件处理程序返回false来过滤键盘输入。

### 调用顺序
* 通过设置对象属性或HTML属性注册的处理程序一直优先
* 使用addEventListener()注册的处理程序按照他们注册的顺序调用
* 使用attachEvent()注册的处理程序**可能**按照任何顺序调用，代码不应依赖于调用顺序

---
##事件传播
事件传播的三个阶段分别是：

1. “捕获”阶段（将addEventListener()的第三个参数设置为true，事件处理处理程序注册为捕获事件处理程序）
2. 第二个阶段是处理程序调用
3. 第三个阶段是事件“冒泡”阶段，它能用在包括IE在内的所有浏览器中，它是事件“捕获”的反向阶段

![.icon](./assets/images/bubble.jpg)
![.icon](./assets/images/event-order-w3c.gif)

---
###事件取消
在支持addEventListener()的浏览器中，通过preventDefault()方法取消事件的默认操作。中IE9之前点IE中，通过设置事件对象的returnValue属性为false来达到同样的效果。

    .javascript
    function cancelHandler(event) {
        var event = event || window.event;
        
        if(event.preventDefault) event.preventDefault();
        if(event.returnValue) event.returnValue = false;
        return false;
    }

---
## 自定义事件
### 观察者模式

![icon](./assets/images/javascript-observer.jpg)

* notify() - trigger()
* subscrible() - addEventListener(), on()
* unsubscribe() - removeEventListener(), off()

---
## 模拟事件对象

    .javascript
     var Event = function() {
        this.subscribers = [];
     };
     Event.prototype = {
        on: function(callback) {
            this.subscribers.push(callback);
        },
        off: function(callback) {
            var i = 0,
            len = this.subscribers.length;

            for (; i < len; i++) {
                if (this.subscribers[i] === callback) {
                    this.subscribers.splice(i, 1);
                    return;
                }
            }
        },

---
### trigger方法    

    .javascript
        trigger: function(data) {
            var i = 0,
            len = this.subscribers.length;

            for (; i < len; i++) {
                this.subscribers[i](data);
            }        
        }
    };

    var handler = function (data) {
        alert(JSON.stringify(data));
    } 

[运行事件对象模拟](./code/events.html)

---
### 
    .javascript
    var Event = function() {
        this.evtMap = {};
    }; 

    Event.prototype = {
        on: function(type, callback) {
            if(!this.evtMap[type]) {
                   this.evtMap[type] = [];
               }
               this.evtMap[type].push(callback);
           },
        off: function(type) {
               delete this.evtMap[type];
        },

---
###
    .javascript
        trigger: function(type, data) {
            if(!this.evtMap[type]) { 
                   return;
               }
               var i = 0,
               len = this.evtMap[type].length;

               for (; i < len; i++) {
                   this.evtMap[type][i](data);
               }        
           }
       };

---



.center.middle
# Node.js er asynkront

No-no:

    .javascript
    var contents = fs.readFileSync('foo.txt');
    console.log(contents);

Yes-yes:

    .javascript
    fs.readFile('foo.txt', function(contents) { 
      console.log(contents); 
    });

---

.center.middle

## Events er innebygd

Innebygde `events.EventEmitter` er vår venn:

    .javascript
    var file = fs.createReadStream('foo.txt');
    file.on('data', function(data) {
      console.log(data);
    });

---

.center.middle

## HTTP er enkelt

    .javascript
    require('http').createServer(
      function(req, res) {
        res.writeHead(200, 
          {'Content-Type': 'text/plain'});
        res.end('Hei, Trondheim!');
    }).listen(1337);

---

.center.middle

## TCP også

    .javascript
    require('net').createServer(function(socket) {
      socket.write('Here be echo.');
      socket.pipe(socket);
    }).listen(1337);

---
.center.middle

## Hvem bruker Node.js?

<img src="presentation/whodunnit.png" width="100%" />

---
.middle

## LinkedIn: Mobil

* iOS
* Android
* WP7
* m.linkedin.com

---
.middle
## Shopify: Batman.js

* Rapportering
* Interne applikasjoner

---
.middle
## Microsoft: Skyen

* Node.js på Windows
* Node.js på Azure
* Node.js i IIS

---

.middle

## Yahoo: Graceful degradation

* Server-side-rendring for inkompatible klienter
* Gjenbruke Javascript
* En stor fremtid for Node.js

---

.middle
## Hva med biblioteker?
* "Operativsystemstøtte" innebygd
  * Prosessmodell
  * Filsystem
  * Nettverk
  * Krypto
  * Etc.
* NPM, pakkesystem for tredjeparts bibliotek

---

.center.middle
<img src="presentation/npm.png" width="80%" />

Innebygd pakkestyring for Node.js

---
.middle
## NPM-kommandoer

* `npm search <query>`
* `npm install <pakke>`
* `npm install -g <pakke>`
* `npm uninstall <pakke>`

---
.middle
## NPM-installeringer

* Pakker lever i `node_modules`
* Globale pakker i global `node_modules`
* Kan installere biblioteker, binærfiler, etc.

---
.center.middle

## Lage egne pakker

`package.json`

    .javascript
    { "name": "openid",
      "description": "OpenID 1.1/2.0 " +
                     "library for node.js",
      "author": { 
        "name": "Håvard Stranden",
        "email": "havard.stranden@gmail.com",
        "web": "http://ox.no" },
      "version": "0.4.1",
      "engines" : [ "node >= 0.6.0" ]
    }

`npm publish`

---

.left.middle

## Toolchain

* Node
* Teksteditor
* Debugger
  * node debug 
  * node-inspector
  * ndb
* IDE
  * Cloud9
  * Jetbrains WebStorm

---

.center.middle
## Demo: Drawnode

---

.center.middle
<img src="presentation/javascriptize.jpg" width="80%" />

---

.center.middle

<img src="presentation/newthing.jpg" width="80%" />

---

.middle
## Callback hell

    .javascript
    fs.readFileSync('foo.txt', function(data) {
      data.split('\n').forEach(function(i, line) {
        line.split(' ').forEach(function(j, word) {
          // ...
        });
      });
    });

---

.middle

## Manglende bibliotek

* SQL?
* ORM?
* XML?

---

.middle
## Endringstakt
* Ustabilt API
* Brukne komponenter
* Lite fullskala-testing

---

.center.middle

## Ting man lurer på

<img src="presentation/philosoraptor.jpg" width="70%" />

---

.center.middle
## Bør jeg bytte til Node.js?

Nei.

---

.center.middle
## Bør jeg vurdere Node.js som plattform?

Ja, i noen tilfeller.

---

.middle
## When to Node, kortversjon:

* Høye ytelseskrav (sanntid)
* Lite budsjett 
* Tilgang på Javascript-kompetanse
* Smalt domene

---

.middle
## Hva med Netty, Twisted, EventMachine, etc.?

* Har du Java-kompetanse og/eller Java-infrastruktur, bruk Netty.
* Har du Python-kompetanse og/eller Python-infrastruktur, bruk Twisted.
* Ser du mønsteret?

---

.center.middle

## Men hva yter BEST?

---

.center.middle
<br />
<img src="presentation/event_timing.png" width="90%" />

Ser du trenden?

---

.center.middle

## Domenet og anvendelsen bestemmer.

Build. Measure.

## Kompetanse er dyrest.

---
.center.middle

## Spørsmål?

<br /><img src="presentation/twitter-blue.png" width="40" valign="middle" /> @havardstranden<br />
<img src="presentation/web.png" width="30" valign="middle" /> http://ox.no
    </textarea>
    <div id="slideshow"></div>
  </body>

</html>


